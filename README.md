# Лабораторная работы №1
Примитивы OpenGL
## Задание для лабораторной работы 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разработать программу, реализующую представление определенного набора примитивов из имеющихся в библиотеке OpenGL(GL_POINT, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, GL_POLYGON).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разработанная на базе шаблона программа должна быть пополнена возможностями остановки интерактивно различных атрибутов примитивов рисования через вызов соответствующих элементов интерфейса пользователя.<br>
## Общие сведения
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В данной лабораторной работе должны быть рассмотрены следующие примитивы:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_POINTS` – каждая вершина рассматривается как отдельная точка, параметры которой не зависят от параметров остальных заданных точек. При этом вершина n определяет точку n. Рисуется N точек (n – номер текущей вершины, N – общее число вершин).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Основой графики OpenGL являются вершины. Для их определения используется команда `glVertex`.<br>
```cpp
void glVertex[2 3 4][s i f d](type coord)
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вызов команды определяется четырьмя координатами x, y, z и w. При этом вызов glVertex2* устанавливает координаты x и y, координата z полагается равной  0, а w – 1. Вызов  glVertex3* устанавливает координаты x, y, z, а w равно 1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_LINES` – каждая пара вершин рассматривается как независимый отрезок. Первые две вершины определяют первый отрезок, следующие две – второй отрезок и т.д., вершины (2n-1) и 2n определяют отрезок n. Всего рисуется N/2 линий. Если число вершин нечетно, то последняя просто игнорируется.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_LINE_STRIP` – в этом режиме рисуется последовательность из одного или нескольких связанных отрезков. Первая вершина задает начало первого отрезка, а вторая – конец первого, который является также началом второго. В общем случае, вершина n (n > 1) определяет начало отрезка n и конец отрезка (n - 1). Всего рисуется (N - 1) отрезок.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_LINE_LOOP` – осуществляется рисование замкнутой кривой линии. Первая вершина задает начало первого отрезка, а вторая – конец первого, который является также началом второго. В общем случае, вершина n (n > 1) определяет начало отрезка n и конец отрезка (n - 1). Первая вершина является концом последнего отрезка. Всего рисуется N  отрезков.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_TRIANGLES` – каждая тройка вершин рассматривается как независимый треугольник. Вершины (3n-2), (3n-1), 3n (в таком порядке) определяют треугольник n. Если число вершин не кратно 3, то оставшиеся ( одна или две) вершины игнорируются. Всего рисуется N/3 треугольника.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_TRIANGLE_STRIP` - в этом режиме рисуется группа связанных треугольников, имеющих общую грань. Первые три вершины определяют первый треугольник, вторая, третья и четвертая – второй и т.д. для нечетного n вершины n, (n+1) и (n+2) определяют треугольник n. Для четного n треугольник определяют вершины (n+1), n и (n+2). Всего рисуется (N-2) треугольника.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_TRIANGLE_FAN` - в этом режиме рисуется группа связанных треугольников, имеющих общие грани и одну общую вершину. Первые три вершины определяют первый треугольник, первая, третья и четвертая – второй и т.д.  Всего рисуется (N-2) треугольника.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_QUADS` – каждая группа из четырех вершин рассматривается как независимый четырехугольник. Вершины (4n-3), (4n-2), (4n-1) и 4n определяют четырехугольник n. Если число вершин не кратно 4, то оставшиеся (одна, две или три) вершины игнорируются. Всего рисуется N/4 четырехугольника.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_QUAD_STRIP` – рисуется группа четырехугольников, имеющих общую грань. Первая группа из четырех вершин задает первый четырехугольник. Третья, четвертая, пятая и шестая задают второй четырехугольник.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_POLYGON` – задет многоугольник. При этом число вершин равно числу вершин рисуемого многоугольника.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![image](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/63317aa4-39b6-43b5-b07e-bd701b33c9ba) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_FRONT` - для лицевых граней, `GL_BACK` - для обратных граней, `GL_FRONT_AND_BACK` - для всех граней. Параметр mode может быть равен:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_POINT` при таком режиме будут отображаться только вершины многоугольников.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_LINE` при таком режиме многоугольник будет представляться набором отрезков.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_FILL` при таком режиме многоугольники будут закрашиваться текущим цветом с учетом освещения, и этот режим установлен по умолчанию.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Также можно указывать, какой тип граней отображать на экране. Для этого сначала на-до установить соответствующий режим вызовом команды `glEnable (GL_CULL_FACE)`, а за- тем выбрать тип отображаемых граней с помощью команды `void glCullFace (GLenum mode)`.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вызов с параметром `GL_FRONT` приводит к удалению из изображения всех лицевых граней, а с параметром `GL_BACK` – обратных (установка по умолчанию).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Кроме рассмотренных стандартных примитивов в библиотеках GLU и GLUT описаны более сложные фигуры, такие как сфера, цилиндр, диск (в GLU) и сфера, куб, конус, тор, тетраэдр, додекаэдр, икосаэдр, октаэдр и чайник (в GLUT). Автоматическое наложение текстуры предусмотрено только для фигур из библиотеки GLU.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Например, чтобы нарисовать сферу или цилиндр, надо сначала создать объект специального типа `GLUquadricObj` с помощью команды `GLUquadricObj* gluNewQuadric(void);`а затем вызвать соответствующую команду:
```cpp
void gluSphere (GLUquadricObj * qobj, GLdouble radius,
                GLint slices, GLint stacks);

void gluCylinder (GLUquadricObj * qobj, 
                  GLdouble baseRadius,
                  GLdouble topRadius, 
                  GLdouble height, GLint slices, 
                  GLint stacks);
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;где параметр slices задает число разбиений вокруг оси z, а stacks – вдоль оси z.<br>
## ЦЕЛЬ, ТРЕБОВАНИЯ И РЕКОМЕНДАЦИИ К ВЫПОЛНЕНИЮ ЗАДАНИЯ
**_Цель выполнения задания:_**<br>
- ознакомление с основными примитивами OpenGL.
- освоение возможности подключения графической библиотеки в среду разработки.<br>

**_Требования и рекомендации к выполнению задания:_**
- проанализировать полученное задание, выделить информационные объекты и действия;
- разработать программу с использованием требуемых примитивов и атрибутов.<br>

**_ЗАДАНИЯ_**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разработать программу, реализующую представление определенного набора примитивов (4+треугольники GL_TRIANGLE_STRIP и полигоны) из имеющихся в OpenGL (GL_POINT, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, GL_POLYGON).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разработанная на базе разработанного вами шаблона программа должна быть пополнена возможностями остановки интерактивно различных атрибутов примитивов рисования через вызов соответствующих элементов интерфейса пользователя.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В качестве рекомендации – предусмотреть расширение интерфейса возможностью добавлять в него следующие лабораторные.<br>
**_ПРИМЕР ВЫПОЛНЕНИЯ ЗАДАНИЯ_**<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_LINES` – каждая пара вершин рассматривается как независимый отрезок. Первые две вершины определяют первый отрезок, следующие две – второй отрезок и т. д., вершины (2n-1) и 2n определяют отрезок n. Всего рисуется N/2 линий. Если число вершин нечетно, то последняя просто игнорируется.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Листинг программы:
```cpp
glLineWidth(12.0f);		 // определение толщины линии	
    glColor3f(0.0f, 0.1f, 0.9f);
    glBegin(GL_LINES);		// сплошная линия
        glVertex2f(-0.75f, 0.45f);
        glVertex2f(0.75f, 0.45f);
    glEnd();

//в одной строке три отрезка с разным стилем рисования
 	glColor3f(0.5f, 0.7f, 1.0f);
	glEnable(GL_LINE_STIPPLE);
	glLineStipple(1,0x0101);	// точечный пунктир
    glBegin(GL_LINES);
        glVertex2f(-0.75f, -0.25f);
        glVertex2f(-0.21f, -0.25f);
	glEnd();
  
	glColor3f(0.0f, 0.1f, 0.9f);
	glLineStipple(1,0x00FF);	// штриховой пунктир
    glBegin(GL_LINES);
        glVertex2f(-0.21f, -0.25f);
        glVertex2f(0.21f, -0.25f);
	glEnd();

	glColor3f(0.0f, 0.5f, 0.7f);
	glLineStipple(1,0x1C47);	// штрих точка штрих
    glBegin(GL_LINES);
        glVertex2f(0.21f, -0.25f);
        glVertex2f(0.75f, -0.25f);
	glEnd();

glDisable(GL_LINE_STIPPLE);
```
Пример работы программы:<br>
![rwerw](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/1c6fc6bb-afe3-4893-8d28-ea2582f79476) <br>
Вывод многоугольника:<br>

![image](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/af1184f9-5168-4996-b500-77db10973df3) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`GL_POLYGON` – задает многоугольник. При этом число вершин равно числу вершин рисуемого многоугольника. Код программы
```cpp
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	glBegin(GL_POLYGON);
		glColor4d(1.0, 1.0, 0.0, 0.7);
		glVertex2d(-0.4,  0.0);
		glVertex2d( 0.4,  0.0);
		glColor4d(0.0, 1.0, 1.0, 0.7);
		glVertex2d( 0.8, -0.4);
		glVertex2d( 0.4, -0.8);
		glVertex2d(-0.4, -0.8);
		glColor4d(1.0, 0.0, 0.0, 0.7);
		glVertex2d( -0.8, -0.4);
	glEnd();
	glDisable(GL_POLYGON_STIPPLE);
```
## Выполнение работы
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Работа выполнена в среде разработки ( С++, С#, Java, Qt,…..)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В отчете обязательно описывать процедуру подключения графической библиотеки в выбранную вами среду разработки.<br>
## Тестирование
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Варианты возможного представления результатов тестирования представлены на снимках экрана<br>
![image](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/12541e51-43f4-44ef-98e6-0f182031a2fe)
![image](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/36959d63-fbe9-4e43-98a4-a5c9650e3a95)
![image](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/b432266c-21c1-4314-b522-e3607495b1f8)
![image](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/d87fdcd1-6a9e-4022-80b9-f25b2130efd0)
![image](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/8c6d54f8-3fcf-4ce2-a64c-0260fdf422a3)
![image](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/32716681-957f-4011-aa98-b6f4f2cf3137)
![image](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/c6697da6-60f7-4bd7-9450-a17ad76e6a00)
![image](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/cef06f84-ca1a-4fb3-985c-df2c1310386a)
![image](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/ab418880-c15d-4791-bd8f-52e9883b9f40)
![image](https://github.com/LeraChernyakova/Computer-graphics/assets/90705580/8cf87924-f5dd-474a-8419-81660cd5dffe)
## Вывод
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В результате выполнения лабораторной работы была разработана программа, создающая графические примитивы OpenGL. Программа работает корректно. При выполнении работы были приобретены навыки работы с графической библиотекой OpenGL. В отчете дб описана среда разработки, **что надо в ней сделать, чтобы подключить OpenGL, привести фрагмент кода подключения и отдельные фрагменты кода программы, реализующей заданные функции с пояснениями.**
